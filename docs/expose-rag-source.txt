
Exposing the red_amber_green.rb as a visible_file...
----------------------------------------------------
This would be good for people wanting to create their own LTF images.
However, it creates a tension because
- it can no longer be trusted to do an eval and call
- so it needs to be eval'd and called by the runner
- a runner call is much slower than a local eval.
However, is a half-way house?
- if the red_amber_green.rb file in the visible-files
  is the same as the one from the image's /usr/local/bin dir
  then it can be trusted.
- which means it can be eval'd and called locally.
- if it is NOT the same
  then eval and call it using the runner.

The problem with this is that puller could pull a new
LTF image with a new /usr/local/bin/red_amber_green.rb file...
and ragger will not see this and so it won't know to flush its cache.
This means resuming an old kata, with an old red_amber_green.rb,
may be slow, since it might never use a local eval and always
use the runner.
But cyber-dojo is not designed for long-lived katas...
Except that you can fork a new kata from a specific traffic-light...

We need ragger to know when puller pulls a new image.
Suppose each LTF image had its SHA inside it, eg as an env-var.
Now: puller.pull_image(image_name)
- get the old image's SHA
- docker pull image_name
- get the new image's SHA
- if the SHA changed, call ragger.new_image(image_name)

Now we have a potential multi-threading issue.
The cache could be accessed from one thread, and refreshed in another thread.
So... [gem install 'concurrent-ruby']
require 'concurrent'
class TrafficLight
  def initialize(external)
    @external = external
    @cache = Concurrent::Map.new
  end
  def colour(...)
    cached = @cache.compute_if_absent(image_name) {
      eval(get_rag_lambda_src(image_name, id), empty_binding)
    }
    rag = cached.call(stdout, stderr, status)
    ...
  end
  def new_image(image_name)
    @cache.delete(image_name)
  end
end
...
Later we will need to keep the source and the lambda
so we can compare the source against the visible_files version...



Initial design thoughts...
--------------------------
When a kata is created, if there is no red_amber_green.rb file,
get the red_amber_green.rb file from the image and add that as a visible_file.
Either way, red_amber_green.rb becomes a special file, like
cyber-dojo.sh and it cannot be deleted.
And it always appears in the lower filenames section.
