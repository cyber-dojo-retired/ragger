
Add API method
ragger.started(image_name, id)
  this is called when a kata is created (group and individual)
  and will populate the cache. It will do
    cache[image_name] ||= ragger_for(image_name)
    def ragger_for(image_name)
      result = runner.run(... image_name, ...)
      rag_rb = result['stdout']
      {
        source: rag_rb
        lambda: eval(rag_rb)
      }
    end

 Very important that start-point image has its rag-lambda checked (by hiker)
   o) it is present in the image
   o) eval'ing is sane

This will prepare the way for putting red_amber_green.rb into the
manifest.json of a start-point and to expose it in the browser.
  o) if red_amber_green.rb from browser matches :source from cache
     (where :source in cache comes from the image)
     we can use the cache
  o) if red_amber_green.rb from browser does NOT match :source from the cache
     (where :source in cache comes from the image)
     we cannot use the cache
     we have to delegate to runner.run(...)
     this will be slower
Note it is important to check the source against the master in the image
because custom sessions could edit their copy of the source.


====================================================

The rag-lambda source would come from the start-point image at first,
(later from the browser as an editable? file), and not from the
test-framework image. This creates a possible security issue
so it may be that the image has to retain a master copy of the rag-lambda
so ragger knows whether it can use its cache or delegate to the runner.



Possible names: lighter?, trafficker?, ragger? colourer?
I think this could be implemented by calling runner...
The runner would be passed the cat command in its cyber-dojo.sh
This still leaves the ragger doing the eval of the lambda src.
It would be nice if the runner did the eval too.
That will be required when the lambda-src is exposed in the browser.
