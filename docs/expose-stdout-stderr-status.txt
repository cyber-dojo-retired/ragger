

The rescue in colour() is catching more errors than it should.
I think it would help if I changed the API so that
colour() returned more than just eg 'red'.

It's tricky because there are several levels here...
Level 0: the 'red' colour from the lambda eval/call with the original [s,s,s]
         if this does _not_ return red/amber/green then I'm thinking
         about returning the string 'faulty' to indicate a faulty traffic-light.
         Then simply have a traffic-light image for faulty.
Level 1: the [s,s,s] triple returned by the call to runner to get the lambda (in stdout)

If the colour(image_name,...) is non-existent then runner
will raise an exception. Eg
{
  "path": "run_cyber_dojo_sh",
  "body": "{\"image_name\":\"does_not_exist\",\"id\":\"375D61\",\"files\":{\"cyber-dojo.sh\":{\"content\":\"cat /usr/local/bin/red_amber_green.rb\",\"truncated\":false}},\"max_seconds\":5}",
  "class": "RunnerStatelessService",
  "message": "{\n  \"command\": \"docker run --name=cyber_dojo_runner_375D61_600c70b7ebc6e7714b608b145d208911 --env CYBER_DOJO_IMAGE_NAME='does_not_exist' --env CYBER_DOJO_ID='375D61' --env CYBER_DOJO_SANDBOX='/sandbox'                            --tmpfs /sandbox:exec,size=50M,uid=41966,gid=51966                                  --tmpfs /tmp:exec,size=50M                                      --ulimit core=0 --ulimit fsize=16777216 --ulimit locks=128 --ulimit nofile=256 --ulimit nproc=128 --ulimit stack=8388608 --memory=512m --net=none --pids-limit=128 --security-opt=no-new-privileges --ulimit data=4294967296                                 --detach                  `# later docker execs`       --init                    `# pid-1 process`            --rm                      `# auto rm on exit`          --user=41966:51966      `# not root` does_not_exist bash -c 'sleep 5'\",\n  \"stdout\": \"\",\n  \"stderr\": \"Unable to find image 'does_not_exist:latest' locally\\ndocker: Error response from daemon: Get https://registry-1.docker.io/v2/: dial tcp: lookup registry-1.docker.io on 10.0.2.3:53: read udp 10.0.2.15:35516->10.0.2.3:53: i/o timeout.\\nSee 'docker run --help'.\\n\",\n  \"status\": 125\n}",
  "backtrace": [...

So...
msg = JSON.parse(error.message)['message']
stdout = msg['stdout']  # ''
stdout = msg['stderr']  # "Unable to find image 'does_not_exist:latest' locally"
status = msg['status']  # '125'

================================================================================

traffic_light.colour: make this also return [stdout,stderr,status]
  I'd like to expose these when I expose the rag-lambda source file
  in the browser.

To prepare for that I can replace the eval() with a call to runner.
It will need its own specific harness files.

Eg, (python_pytest)
lambda { |stdout,stderr,status|
  output = stdout + stderr
  return :red   if /=== FAILURES ===/.match(output)
  return :green if /=== (\d+) passed/.match(output)
  return :amber
}

@cache[image_name] ||= get_rag_lambda_src(image_name, id)
ruby = 'cyberdojofoundation/ruby'
files = {
  "cyber-dojo.sh" => intact("ruby ./traffic_light.rb"),
  "lambda.rb" => intact(@cache[image_name]),
  "stdout" => stdout,
  "stderr" => stderr,
  "status" => status,
  "traffic_light.rb" =>
    <<~RUBY
    rag = eval(IO.read('lambda.rb'))
    stdout = IO.read('stdout')
    stderr = IO.read('stderr')
    status = IO.read('status')
    print rag.call(stdout, stderr, status)
    RUBY
}
max_seconds = 5
result = runner.run_cyber_dojo_sh(ruby, id, files, max_seconds)
rgb = result['stdout']['content'].strip
rgb =~ /^red|amber|green$/ ? rgb : 'amber'


def get_rag_lambda_src(image_name, id)
  files = { 'cyber-dojo.sh' => 'cat /usr/local/bin/red_amber_green.rb' }
  max_seconds = 5
  result = runner.run_cyber_dojo_sh(image_name, id, files, max_seconds)
  result['stdout']['content']
end

Now light['stdout'], light['stderr'], light['status']
can all be exposed in the browser.

An issue with this is that doing the runner.run is a lot slower
than doing the eval. But, I think I can get the both of best worlds.
The red_amber_green.rb source can be editable in the browser.
Initially this will come from the image or the start-point.
When the ragger is sent red_amber_green.rb it can compare it against
the original. If it has not changed it can use the already eval'd
function, which is ready to go. If it has changed, it can send it
to the runner.

- - - - - - - - - - - - - - - - - - - - - - - - - -

Note, dropping sss from main kata [test] page
and showing sss when in [resume] mode
means [test] page could actually have files
called stdout,stderr,status if it wished!!!
